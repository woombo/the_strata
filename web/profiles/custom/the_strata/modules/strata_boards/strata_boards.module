<?php

/**
 * @file
 * Primary module hooks for Strata Boards module.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Url;
use Drupal\node\NodeInterface;

/**
 * Callback for allowed values of field_board_entity_type.
 *
 * Returns a list of content types that can be managed on a board.
 */
function strata_boards_get_content_types(FieldStorageDefinitionInterface $definition, ?FieldableEntityInterface $entity = NULL, bool &$cacheable = TRUE): array {
  $cacheable = TRUE;
  $options = [];

  // Get all node types.
  $node_types = \Drupal::entityTypeManager()
    ->getStorage('node_type')
    ->loadMultiple();

  // Exclude board itself from the options.
  foreach ($node_types as $type_id => $type) {
    if ($type_id !== 'board') {
      $options[$type_id] = $type->label();
    }
  }

  return $options;
}

/**
 * Implements hook_node_access().
 *
 * Restrict viewing of board and ticket content to users with 'access strata boards' permission.
 */
function strata_boards_node_access(NodeInterface $node, string $op, AccountInterface $account): AccessResult {
  // Only affect board and ticket content types.
  if (!in_array($node->bundle(), ['board', 'ticket'])) {
    return AccessResult::neutral();
  }

  // For view operations, require 'access strata boards' permission.
  if ($op === 'view') {
    $has_access = $account->hasPermission('access strata boards');
    return AccessResult::forbiddenIf(!$has_access, 'You do not have permission to view this content.')
      ->addCacheContexts(['user.permissions'])
      ->cachePerPermissions();
  }

  return AccessResult::neutral();
}

/**
 * Implements hook_page_attachments().
 *
 * Add meta robots tag to prevent search engine indexing.
 */
function strata_boards_page_attachments(array &$attachments): void {
  // Add noindex, nofollow meta tag to all pages.
  $attachments['#attached']['html_head'][] = [
    [
      '#type' => 'html_tag',
      '#tag' => 'meta',
      '#attributes' => [
        'name' => 'robots',
        'content' => 'noindex, nofollow',
      ],
    ],
    'robots',
  ];

  // Add X-Robots-Tag header as well for additional coverage.
  $attachments['#attached']['http_header'][] = [
    'X-Robots-Tag',
    'noindex, nofollow',
  ];
}

/**
 * Implements hook_toolbar().
 */
function strata_boards_toolbar(): array {
  $items = [];

  $items['strata'] = [
    '#type' => 'toolbar_item',
    '#weight' => -5,
    'tab' => [
      '#type' => 'link',
      '#title' => t('Strata'),
      '#url' => Url::fromRoute('view.strata_boards.page_1'),
      '#attributes' => [
        'title' => t('Strata management'),
        'class' => ['toolbar-icon', 'toolbar-icon-strata'],
      ],
    ],
    'tray' => [
      '#heading' => t('Strata management'),
      'strata_menu' => [
        '#theme' => 'item_list',
        '#items' => [
          'boards' => [
            '#type' => 'link',
            '#title' => t('Boards'),
            '#url' => Url::fromRoute('view.strata_boards.page_1'),
            '#attributes' => ['class' => ['toolbar-icon', 'toolbar-icon-strata-boards']],
          ],
          'tickets' => [
            '#type' => 'link',
            '#title' => t('Tickets'),
            '#url' => Url::fromRoute('view.strata_tickets.page_1'),
            '#attributes' => ['class' => ['toolbar-icon', 'toolbar-icon-strata-tickets']],
          ],
          'notices' => [
            '#type' => 'link',
            '#title' => t('Notices'),
            '#url' => Url::fromRoute('view.strata_notices.page_1'),
            '#attributes' => ['class' => ['toolbar-icon', 'toolbar-icon-strata-notices']],
          ],
          'polls' => [
            '#type' => 'link',
            '#title' => t('Polls'),
            '#url' => Url::fromRoute('view.strata_polls.page_1'),
            '#attributes' => ['class' => ['toolbar-icon', 'toolbar-icon-strata-polls']],
          ],
        ],
        '#attributes' => [
          'class' => ['toolbar-menu'],
        ],
      ],
    ],
    '#attached' => [
      'library' => [
        'strata_boards/toolbar',
      ],
    ],
  ];

  return $items;
}

/**
 * Implements hook_theme().
 */
function strata_boards_theme(): array {
  return [
    'strata_board' => [
      'variables' => [
        'board' => NULL,
        'description' => NULL,
        'columns' => [],
        'entity_type' => 'ticket',
        'entity_type_label' => 'Ticket',
        'add_ticket_url' => NULL,
        'all_tickets_url' => NULL,
      ],
      'template' => 'strata-board',
    ],
    'strata_ticket_card' => [
      'variables' => [
        'ticket' => NULL,
        'title' => NULL,
        'description' => NULL,
        'deadline' => NULL,
        'ticket_type' => NULL,
        'assigned_to' => NULL,
        'ticket_url' => NULL,
        'comment_count' => 0,
        'file_count' => 0,
        'created' => NULL,
      ],
      'template' => 'strata-ticket-card',
    ],
    'strata_boards_list' => [
      'variables' => [
        'boards' => [],
        'create_url' => NULL,
      ],
      'template' => 'strata-boards-list',
    ],
  ];
}

/**
 * Implements hook_theme_registry_alter().
 *
 * Override poll_meter template to display voters.
 */
function strata_boards_theme_registry_alter(array &$theme_registry): void {
  if (isset($theme_registry['poll_meter'])) {
    $module_path = \Drupal::service('extension.list.module')->getPath('strata_boards');
    $theme_registry['poll_meter']['path'] = $module_path . '/templates';
  }
}

/**
 * Implements hook_preprocess_poll_results().
 *
 * Attach poll library for styling.
 */
function strata_boards_preprocess_poll_results(array &$variables): void {
  $variables['#attached']['library'][] = 'strata_boards/poll';
}

/**
 * Implements hook_form_alter().
 *
 * Applies board-related form alterations to any node form with board fields.
 */
function strata_boards_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  // Only process node forms.
  $form_object = $form_state->getFormObject();
  if (!$form_object instanceof \Drupal\Core\Entity\EntityFormInterface) {
    return;
  }

  $entity = $form_object->getEntity();
  if (!$entity instanceof NodeInterface || $entity->bundle() === 'board') {
    return;
  }

  // Check if this content type has both board fields.
  if (!isset($form['field_board_ref']) || !isset($form['field_board_status'])) {
    return;
  }

  // Determine if this is a new node or an edit.
  $is_new = $entity->isNew();

  if ($is_new) {
    // For new nodes, check for board ID in query parameter.
    $request = \Drupal::request();
    $board_id = $request->query->get('board');

    if ($board_id) {
      $board = \Drupal::entityTypeManager()
        ->getStorage('node')
        ->load($board_id);

      if ($board && $board->bundle() === 'board') {
        $form['field_board_ref']['widget'][0]['target_id']['#default_value'] = $board;

        // Filter status options based on board's selected columns.
        _strata_boards_filter_status_options($form, $board);
      }
    }

    // Pre-populate status from query parameter or default to first available option.
    $status_id = $request->query->get('status');
    if ($status_id) {
      $form['field_board_status']['widget']['#default_value'] = [$status_id];
    }
    elseif (empty($form['field_board_status']['widget']['#default_value'])) {
      _strata_boards_set_default_status($form);
    }
  }
  else {
    // For existing nodes, get the board from the entity.
    if ($entity->hasField('field_board_ref') && !$entity->get('field_board_ref')->isEmpty()) {
      $board = $entity->get('field_board_ref')->entity;
      if ($board) {
        _strata_boards_filter_status_options($form, $board);
      }
    }
  }
}

/**
 * Sets the default status to the first available option or "ToDo" if available.
 *
 * @param array &$form
 *   The form array.
 */
function _strata_boards_set_default_status(array &$form): void {
  $options = $form['field_board_status']['widget']['#options'] ?? [];
  unset($options['_none']);

  if (empty($options)) {
    return;
  }

  // Try to find "ToDo" in the available options.
  $terms = \Drupal::entityTypeManager()
    ->getStorage('taxonomy_term')
    ->loadByProperties([
      'vid' => 'board_column',
      'name' => 'ToDo',
    ]);

  if ($terms) {
    $todo_term = reset($terms);
    if (isset($options[$todo_term->id()])) {
      $form['field_board_status']['widget']['#default_value'] = [$todo_term->id()];
      return;
    }
  }

  // Fall back to the first available option.
  $form['field_board_status']['widget']['#default_value'] = [array_key_first($options)];
}

/**
 * Helper function to filter status options based on board's selected columns.
 *
 * @param array &$form
 *   The form array.
 * @param \Drupal\node\NodeInterface $board
 *   The board node.
 */
function _strata_boards_filter_status_options(array &$form, NodeInterface $board): void {
  // Check if the board has specific columns selected.
  if (!$board->hasField('field_board_columns') || $board->get('field_board_columns')->isEmpty()) {
    // No specific columns selected, show all options.
    return;
  }

  // Get the selected column IDs from the board.
  $allowed_column_ids = [];
  foreach ($board->get('field_board_columns') as $item) {
    $allowed_column_ids[] = $item->target_id;
  }

  // Filter the status options to only include allowed columns.
  if (isset($form['field_board_status']['widget']['#options'])) {
    $original_options = $form['field_board_status']['widget']['#options'];
    $filtered_options = [];

    foreach ($original_options as $key => $value) {
      // Keep the '_none' option if it exists.
      if ($key === '_none') {
        $filtered_options[$key] = $value;
      }
      // Only include options that are in the allowed list.
      elseif (in_array($key, $allowed_column_ids)) {
        $filtered_options[$key] = $value;
      }
    }

    $form['field_board_status']['widget']['#options'] = $filtered_options;
  }
}

/**
 * Implements hook_ENTITY_TYPE_view_alter() for node entities.
 */
function strata_boards_node_view_alter(array &$build, NodeInterface $node, EntityViewDisplayInterface $display): void {
  // For board nodes in full/default view mode, replace the content with the board view.
  if ($node->bundle() === 'board' && in_array($display->getMode(), ['full', 'default'])) {
    // Get the board controller and render the board view.
    $controller = \Drupal::classResolver()->getInstanceFromDefinition(
      'Drupal\strata_boards\Controller\BoardController'
    );
    $board_build = $controller->view($node);

    // Clear existing build except metadata.
    foreach (array_keys($build) as $key) {
      if (!str_starts_with($key, '#') && $key !== '_layout_builder') {
        unset($build[$key]);
      }
    }

    // Merge in the board view and ensure cache is invalidated.
    $build['board_view'] = $board_build;

    // Add cache tags to ensure proper invalidation.
    $build['#cache']['tags'][] = 'node_list:ticket';
  }

  // For ticket nodes, add wrapper class to comments field and attach library.
  if ($node->bundle() === 'ticket' && in_array($display->getMode(), ['full', 'default'])) {
    // Attach the ticket CSS library.
    $build['#attached']['library'][] = 'strata_boards/ticket';

    // Add wrapper class for the ticket view.
    $build['#attributes']['class'][] = 'strata-ticket-view';

    // Build the metadata section with styled badges.
    $meta_items = [];

    // Status badge.
    if (isset($build['field_board_status']) && $node->hasField('field_board_status') && !$node->get('field_board_status')->isEmpty()) {
      $status_term = $node->get('field_board_status')->entity;
      if ($status_term) {
        $status_name = $status_term->label();
        $status_class = strtolower(str_replace(' ', '-', $status_name));
        $meta_items['status'] = [
          '#type' => 'html_tag',
          '#tag' => 'span',
          '#value' => $status_name,
          '#attributes' => [
            'class' => ['strata-ticket-meta__status', 'strata-ticket-meta__status--' . $status_class],
          ],
          '#weight' => 0,
        ];
        unset($build['field_board_status']);
      }
    }

    // Type badge.
    if (isset($build['field_ticket_type']) && $node->hasField('field_ticket_type') && !$node->get('field_ticket_type')->isEmpty()) {
      $type_term = $node->get('field_ticket_type')->entity;
      if ($type_term) {
        $type_name = $type_term->label();
        $type_class = strtolower(str_replace(' ', '-', $type_name));
        $meta_items['type'] = [
          '#type' => 'html_tag',
          '#tag' => 'span',
          '#value' => $type_name,
          '#attributes' => [
            'class' => ['strata-ticket-meta__type', 'strata-ticket-meta__type--' . $type_class],
          ],
          '#weight' => 1,
        ];
        unset($build['field_ticket_type']);
      }
    }

    // Assigned to badge.
    if (isset($build['field_ticket_assigned_to']) && $node->hasField('field_ticket_assigned_to') && !$node->get('field_ticket_assigned_to')->isEmpty()) {
      $assigned_user = $node->get('field_ticket_assigned_to')->entity;
      if ($assigned_user) {
        $display_name = $assigned_user->getDisplayName();
        $initials = _strata_boards_get_initials($display_name);
        $user_url = $assigned_user->toUrl()->toString();

        $meta_items['assigned'] = [
          '#type' => 'html_tag',
          '#tag' => 'span',
          '#attributes' => [
            'class' => ['strata-ticket-meta__assigned'],
          ],
          '#weight' => 2,
          'avatar' => [
            '#type' => 'html_tag',
            '#tag' => 'span',
            '#value' => $initials,
            '#attributes' => [
              'class' => ['strata-ticket-meta__assigned-avatar'],
            ],
          ],
          'name' => [
            '#type' => 'link',
            '#title' => $display_name,
            '#url' => $assigned_user->toUrl(),
          ],
        ];
        unset($build['field_ticket_assigned_to']);
      }
    }

    // Deadline badge.
    if (isset($build['field_ticket_deadline']) && $node->hasField('field_ticket_deadline') && !$node->get('field_ticket_deadline')->isEmpty()) {
      $deadline_value = $node->get('field_ticket_deadline')->value;
      if ($deadline_value) {
        $deadline_timestamp = strtotime($deadline_value);
        $formatted_date = \Drupal::service('date.formatter')->format($deadline_timestamp, 'custom', 'M j, Y');

        // Determine if overdue or soon.
        $now = time();
        $days_until = ($deadline_timestamp - $now) / 86400;
        $deadline_class = '';
        if ($days_until < 0) {
          $deadline_class = 'strata-ticket-meta__deadline--overdue';
        }
        elseif ($days_until <= 3) {
          $deadline_class = 'strata-ticket-meta__deadline--soon';
        }

        // Calendar icon SVG.
        $calendar_icon = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>';

        $meta_items['deadline'] = [
          '#type' => 'html_tag',
          '#tag' => 'span',
          '#attributes' => [
            'class' => array_filter(['strata-ticket-meta__deadline', $deadline_class]),
          ],
          '#weight' => 3,
          'icon' => [
            '#type' => 'inline_template',
            '#template' => $calendar_icon,
          ],
          'date' => [
            '#type' => 'html_tag',
            '#tag' => 'span',
            '#value' => $formatted_date,
          ],
        ];
        unset($build['field_ticket_deadline']);
      }
    }

    // Add the metadata section if we have items.
    if (!empty($meta_items)) {
      $build['ticket_meta'] = [
        '#type' => 'container',
        '#attributes' => [
          'class' => ['strata-ticket-meta'],
        ],
        '#weight' => -100,
      ] + $meta_items;
    }

    // Embed the strata_media view for files.
    if ($node->hasField('field_ticket_files') && !$node->get('field_ticket_files')->isEmpty()) {
      $media_ids = [];
      foreach ($node->get('field_ticket_files') as $item) {
        if ($item->target_id) {
          $media_ids[] = $item->target_id;
        }
      }
      if (!empty($media_ids)) {
        $build['ticket_files'] = [
          '#type' => 'container',
          '#attributes' => [
            'class' => ['strata-ticket-files'],
          ],
          '#weight' => 6,
          'label' => [
            '#type' => 'html_tag',
            '#tag' => 'h3',
            '#value' => t('Files'),
            '#attributes' => [
              'class' => ['strata-ticket-files__label'],
            ],
          ],
          'view' => views_embed_view('strata_media', 'embed_1', implode('+', $media_ids)),
        ];
      }
    }

    // Wrap the comments field with our custom class.
    if (isset($build['field_ticket_comments'])) {
      $build['field_ticket_comments']['#prefix'] = '<div class="strata-ticket-comments">';
      $build['field_ticket_comments']['#suffix'] = '</div>';
    }
  }
}

/**
 * Get initials from a display name.
 */
function _strata_boards_get_initials(string $name): string {
  $parts = explode(' ', trim($name));
  if (count($parts) >= 2) {
    return strtoupper(substr($parts[0], 0, 1) . substr(end($parts), 0, 1));
  }
  return strtoupper(substr($name, 0, 2));
}

/**
 * Implements hook_entity_embed_alter().
 *
 * Adds entity type class to embedded entity wrapper.
 */
function strata_boards_entity_embed_alter(array &$build, EntityInterface $entity, array $context): void {
  // Add class based on entity type.
  $entity_type = $entity->getEntityTypeId();
  $build['#attributes']['class'][] = 'embedded-entity--' . str_replace('_', '-', $entity_type);

  // For entities with bundles, add bundle-specific class.
  if (method_exists($entity, 'bundle')) {
    $bundle = $entity->bundle();
    $build['#attributes']['class'][] = 'embedded-entity--' . str_replace('_', '-', $entity_type) . '--' . str_replace('_', '-', $bundle);
  }
}

/**
 * Implements hook_preprocess_poll_meter().
 *
 * Adds list of voters to each poll option.
 */
function strata_boards_preprocess_poll_meter(array &$variables): void {
  $variables['voters'] = [];

  // Get the poll entity from the render array.
  if (!isset($variables['poll'])) {
    return;
  }

  $poll = $variables['poll'];
  if (!$poll instanceof \Drupal\poll\PollInterface) {
    return;
  }

  // Get the choice ID from the value attribute (it's the vote count for this choice).
  // We need to find the choice ID by matching the choice label.
  $choice_markup = $variables['choice'] ?? NULL;
  if (!$choice_markup) {
    return;
  }

  // Render the choice to get the text.
  $choice_text = '';
  if (is_array($choice_markup) && isset($choice_markup['#markup'])) {
    $choice_text = $choice_markup['#markup'];
  }
  elseif (is_string($choice_markup)) {
    $choice_text = $choice_markup;
  }

  // Find the choice ID by matching the option text.
  $options = $poll->getOptions();
  $choice_id = NULL;
  foreach ($options as $cid => $option_text) {
    if ($option_text === $choice_text) {
      $choice_id = $cid;
      break;
    }
  }

  if ($choice_id === NULL) {
    return;
  }

  // Query the poll_vote table for voters on this choice.
  $database = \Drupal::database();
  $query = $database->select('poll_vote', 'pv')
    ->fields('pv', ['uid'])
    ->condition('pv.pid', $poll->id())
    ->condition('pv.chid', $choice_id);
  $uids = $query->execute()->fetchCol();

  if (empty($uids)) {
    return;
  }

  // Load user entities and build voter list.
  $users = \Drupal::entityTypeManager()->getStorage('user')->loadMultiple($uids);
  foreach ($users as $user) {
    if ($user->id() == 0) {
      $variables['voters'][] = [
        'name' => t('Anonymous'),
        'url' => NULL,
      ];
    }
    else {
      $variables['voters'][] = [
        'name' => $user->getDisplayName(),
        'url' => $user->toUrl()->toString(),
      ];
    }
  }
}
